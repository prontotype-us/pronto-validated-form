// Generated by CoffeeScript 1.8.0
var Checkbox, ObjectEditor, React, Toggle, ValidatedField, ValidatedForm, ValidatedFormMixin, classSet, helpers, validation,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

React = require('react');

classSet = require('react-classset');

helpers = require('./helpers');

validation = require('./validation');

ObjectEditor = require('object-editor');

ValidatedFormMixin = {
  resetState: function() {
    return this.setState(this.getInitialState());
  },
  validate: function() {
    return helpers.compactObj(helpers.mapObjKey(this.props.fields, (function(_this) {
      return function(field_name) {
        var _ref;
        return (_ref = _this.refs[field_name]) != null ? _ref.validate() : void 0;
      };
    })(this)));
  },
  trySubmit: function(e) {
    var errors, values;
    e.preventDefault();
    if (!this.state.loading) {
      this.setState({
        errors: {}
      });
      errors = this.validate();
      if (Object.keys(errors).length > 0) {
        return this.setState({
          errors: errors
        });
      } else {
        values = this.state.values;
        return this.setState({
          loading: true
        }, (function(_this) {
          return function() {
            var _base;
            if (_this.props.onSubmit != null) {
              return typeof (_base = _this.props).onSubmit === "function" ? _base.onSubmit(values, _this.onUpdated) : void 0;
            } else if (_this.onSubmit != null) {
              return _this.onSubmit(values);
            }
          };
        })(this));
      }
    }
  },
  onUpdated: function() {
    return this.setState({
      changed: false
    });
  },
  onChange: function(key) {
    return (function(_this) {
      return function(value) {
        var values;
        values = _this.state.values || {};
        values[key] = value;
        return _this.setState({
          values: values,
          changed: true
        }, function() {
          return typeof _this.onChanged === "function" ? _this.onChanged(key, value) : void 0;
        });
      };
    })(this);
  },
  clear: function() {
    return this.setState({
      values: {},
      errors: {},
      changed: false
    });
  },
  renderFields: function() {
    return React.createElement("div", null, Object.keys(this.props.fields).map((function(_this) {
      return function(field_name) {
        return _this.renderField(field_name);
      };
    })(this)));
  },
  renderField: function(field_name) {
    var field, _ref, _ref1;
    field = this.props.fields[field_name];
    return React.createElement(ValidatedField, React.__spread({}, field, {
      "ref": field_name,
      "key": field_name,
      "name": field_name,
      "value": (_ref = this.state.values) != null ? _ref[field_name] : void 0,
      "values": this.state.values,
      "error": (_ref1 = this.state.errors) != null ? _ref1[field_name] : void 0,
      "onChange": this.onChange(field_name)
    }));
  }
};

ValidatedField = React.createClass({
  getDefaultProps: function() {
    return {
      type: 'text'
    };
  },
  value: function() {
    return this.props.value;
  },
  validate: function() {
    var validator;
    if (this.isOptional() || this.isHidden()) {
      return null;
    }
    validator = this.props.validator || validation['valid_' + this.props.type] || validation.exists;
    if (!validator(this.props.value)) {
      if (this.props.error_message) {
        return this.props.error_message;
      } else if (!this.props.value) {
        return "Empty " + (helpers.unslugify(this.props.name));
      } else {
        return "Invalid " + (helpers.unslugify(this.props.name));
      }
    }
    return null;
  },
  changeValue: function(e) {
    var value;
    value = e.target != null ? e.target.value : e;
    return this.props.onChange(value);
  },
  toggleValue: function(e) {
    var current_values, value;
    value = e.target != null ? e.target.value : e;
    console.log('toggling my value', value);
    current_values = this.value() || [];
    console.log('my current value', current_values);
    if (__indexOf.call(current_values, value) >= 0) {
      current_values = current_values.filter(function(v) {
        return v !== value;
      });
    } else {
      current_values.push(value);
    }
    return this.props.onChange(current_values);
  },
  focus: function() {
    return this.refs.field.focus();
  },
  isOptional: function() {
    if (typeof this.props.optional === 'function') {
      return this.props.optional(this.props.values);
    } else if (this.props.optional) {
      return true;
    }
    return false;
  },
  isHidden: function() {
    if (typeof this.props.hidden === 'function') {
      return this.props.hidden(this.props.values);
    } else if (this.props.hidden) {
      return true;
    }
    return false;
  },
  render: function() {
    var dashless, form_group_class, form_group_class_set, value, _ref, _value;
    if (this.isHidden()) {
      return React.createElement("div", {
        "className": 'validated-field-hidden'
      });
    }
    form_group_class_set = {
      'form-group': true,
      'has-error': this.props.error,
      'required': !this.isOptional()
    };
    form_group_class_set["" + this.props.name] = true;
    form_group_class_set["" + this.props.className] = true;
    form_group_class = classSet(form_group_class_set);
    _value = this.props.value || '';
    if (this.props.type === 'phone') {
      dashless = _value.replace(/-/g, '');
      if (dashless.length === 4) {
        value = dashless.slice(0, 3) + '-' + dashless.slice(3);
      } else if (dashless.length === 7) {
        value = dashless.slice(0, 3) + '-' + dashless.slice(3, 6) + '-' + dashless.slice(6);
      } else {
        value = _value;
      }
    } else {
      value = _value;
    }
    return React.createElement("div", {
      "className": form_group_class
    }, ((_ref = this.props.type) !== 'hidden' && _ref !== 'checkbox' ? React.createElement("label", {
      "htmlFor": "validated-field-" + this.props.name
    }, (this.props.icon ? React.createElement("i", {
      "className": "fa fa-" + this.props.icon
    }) : void 0), React.createElement("span", null, this.props.label || helpers.humanize(this.props.name))) : void 0), ((function() {
      switch (this.props.type) {
        case 'toggle':
          return React.createElement(Toggle, {
            "key": this.props.name,
            "options": this.props.options,
            "onChange": this.changeValue,
            "selected": this.props.value
          });
        case 'select':
          return React.createElement("select", {
            "id": "validated-field-" + this.props.name,
            "value": value,
            "onChange": this.changeValue
          }, React.createElement("option", {
            "disabled": true,
            "value": ''
          }, this.props.placeholder || 'Select one'), this.props.options.map(function(o) {
            return React.createElement("option", {
              "key": o.value || o,
              "value": o.value || o
            }, o.display || o);
          }));
        case 'select-multi':
          return React.createElement("select", {
            "id": "validated-field-" + this.props.name,
            "value": value,
            "multiple": true,
            "onChange": this.toggleValue
          }, React.createElement("option", {
            "disabled": true
          }, this.props.placeholder || 'Select multi'), this.props.options.map(function(o) {
            return React.createElement("option", {
              "key": o.value || o,
              "value": o.value || o
            }, o.display || o);
          }));
        case 'textarea':
          return React.createElement("textarea", {
            "key": this.props.name,
            "ref": 'field',
            "id": "validated-field-" + this.props.name,
            "name": this.props.name,
            "type": this.props.type,
            "placeholder": this.props.placeholder || helpers.humanize(this.props.name),
            "value": value,
            "onChange": this.changeValue,
            "autoComplete": this.props.autoComplete,
            "autoCorrect": this.props.autoCorrect
          });
        case 'object':
          return React.createElement(ObjectEditor, {
            "object": value || {},
            "onSave": this.changeValue
          });
        case 'checkbox':
          return React.createElement(Checkbox, {
            "key": this.props.name,
            "name": this.props.name,
            "icon": this.props.icon,
            "label": this.props.label,
            "onChange": this.changeValue,
            "checked": this.props.value
          });
        default:
          return React.createElement("input", {
            "key": this.props.name,
            "ref": 'field',
            "id": "validated-field-" + this.props.name,
            "name": this.props.name,
            "type": this.props.type,
            "placeholder": this.props.placeholder || helpers.humanize(this.props.name),
            "value": value,
            "onChange": this.changeValue,
            "autoComplete": this.props.autoComplete,
            "autoCorrect": this.props.autoCorrect
          });
      }
    }).call(this)), (this.props.error ? React.createElement("span", {
      "className": 'error'
    }, this.props.error) : void 0));
  }
});

ValidatedForm = React.createClass({
  mixins: [ValidatedFormMixin],
  getInitialState: function() {
    return {
      loading: false,
      changed: false,
      values: this.props.values || {}
    };
  },
  onChanged: function(key, value) {
    var _base;
    return typeof (_base = this.props).onChanged === "function" ? _base.onChanged(key, value) : void 0;
  },
  render: function() {
    return React.createElement("form", {
      "onSubmit": this.trySubmit,
      "className": 'validated-form'
    }, this.renderFields(), React.createElement("button", {
      "disabled": !this.state.changed
    }, (this.state.loading ? "Loading..." : "Submit")));
  }
});

Checkbox = React.createClass({
  getInitialState: function() {
    return {
      checked: this.props.checked || false
    };
  },
  toggleCheck: function() {
    return this.setState({
      checked: !this.state.checked
    }, (function(_this) {
      return function() {
        var _base;
        return typeof (_base = _this.props).onChange === "function" ? _base.onChange(_this.state.checked) : void 0;
      };
    })(this));
  },
  render: function() {
    return React.createElement("div", {
      "className": 'checkbox'
    }, React.createElement("input", {
      "type": 'checkbox',
      "id": "validated-field-" + this.props.name,
      "name": this.props.name,
      "checked": this.state.checked,
      "onChange": this.toggleCheck
    }), React.createElement("label", {
      "htmlFor": "validated-field-" + this.props.name
    }, (this.props.icon ? React.createElement("i", {
      "className": "fa fa-" + this.props.icon
    }) : void 0), (this.props.label != null ? this.props.label : React.createElement("span", null, helpers.humanize(this.props.name)))));
  }
});

Toggle = React.createClass({
  getInitialState: function() {
    return {
      selected: this.props.selected || ''
    };
  },
  select: function(key) {
    return (function(_this) {
      return function() {
        var _base;
        _this.value = key;
        _this.setState({
          selected: key
        });
        return typeof (_base = _this.props).onChange === "function" ? _base.onChange(key) : void 0;
      };
    })(this);
  },
  selected: function(key) {
    if (this.state.selected === key) {
      return 'selected';
    } else {
      return '';
    }
  },
  render: function() {
    return React.createElement("div", {
      "className": 'toggle'
    }, this.props.options.map(this.renderOption));
  },
  renderOption: function(option, i) {
    return React.createElement("a", {
      "key": i,
      "onClick": this.select(option),
      "className": this.selected(option)
    }, option);
  }
});

module.exports = {
  ValidatedField: ValidatedField,
  ValidatedFormMixin: ValidatedFormMixin,
  ValidatedForm: ValidatedForm
};
