// Generated by CoffeeScript 1.10.0
var React, Toggle, ValidatedField, ValidatedFormMixin, _, classSet, helpers, validation;

_ = require('underscore');

React = require('react');

classSet = require('react-classset');

helpers = require('./helpers');

validation = require('./validation');

ValidatedFormMixin = {
  resetState: function() {
    return this.setState(this.getInitialState());
  },
  validate: function() {
    return helpers.compactObj(helpers.mapObjKey(this.props.fields, (function(_this) {
      return function(field_name) {
        var ref;
        return (ref = _this.refs[field_name]) != null ? ref.validate() : void 0;
      };
    })(this)));
  },
  values: function() {
    return helpers.mapObjKey(this.props.fields, (function(_this) {
      return function(field_name) {
        var ref;
        return (ref = _this.refs[field_name]) != null ? ref.value() : void 0;
      };
    })(this));
  },
  trySubmit: function(e) {
    var errors, values;
    e.preventDefault();
    if (!this.state.loading) {
      this.setState({
        errors: {}
      });
      errors = this.validate();
      if (Object.keys(errors).length > 0) {
        return this.setState({
          errors: errors
        });
      } else {
        values = this.values();
        return this.onSubmit(values);
      }
    }
  },
  onChange: function(key) {
    return (function(_this) {
      return function(value) {
        var values;
        values = _this.state.values || {};
        values[key] = value;
        return _this.setState({
          values: values
        }, function() {
          return typeof _this.onChanged === "function" ? _this.onChanged(key, value) : void 0;
        });
      };
    })(this);
  },
  clear: function() {
    return this.setState({
      values: {},
      errors: {}
    });
  },
  renderFields: function() {
    return React.createElement("div", null, Object.keys(this.props.fields).map((function(_this) {
      return function(field_name) {
        return _this.renderField(field_name);
      };
    })(this)));
  },
  renderField: function(field_name) {
    var field, ref, ref1;
    field = this.props.fields[field_name];
    return React.createElement(ValidatedField, Object.assign({}, field, {
      "ref": field_name,
      "key": field_name,
      "name": field_name,
      "value": (ref = this.state.values) != null ? ref[field_name] : void 0,
      "error": (ref1 = this.state.errors) != null ? ref1[field_name] : void 0,
      "onChange": this.onChange(field_name),
      "values": this.state.values
    }));
  }
};

ValidatedField = React.createClass({displayName: "ValidatedField",
  getDefaultProps: function() {
    return {
      type: 'text'
    };
  },
  value: function() {
    return this.props.value;
  },
  validate: function() {
    var validator;
    if (_.isFunction(this.props.optional)) {
      if (this.props.optional(this.props.values)) {
        return null;
      }
    } else if (this.props.optional) {
      return null;
    }
    if (_.isFunction(this.props.hidden)) {
      if (this.props.hidden(this.props.values)) {
        return null;
      }
    } else if (this.props.hidden) {
      return null;
    }
    validator = this.props.validator || validation[this.props.type] || validation.exists;
    if (!validator(this.props.value)) {
      return this.props.error_message || ("Nothing in " + this.props.name);
    }
    return null;
  },
  changeValue: function(e) {
    var value;
    value = e.target != null ? e.target.value : e;
    return this.props.onChange(value);
  },
  focus: function() {
    return this.refs.field.focus();
  },
  isOptional: function() {
    if (_.isFunction(this.props.optional)) {
      return this.props.optional(this.props.values);
    } else if (this.props.optional) {
      return true;
    } else {
      return false;
    }
  },
  render: function() {
    var _value, dashless, form_group_class, obj, value;
    form_group_class = classSet((
      obj = {
        'form-group': true
      },
      obj["" + this.props.name] = true,
      obj["" + this.props.className] = true,
      obj['has-error'] = this.props.error,
      obj['required'] = !this.isOptional(),
      obj
    ));
    _value = this.props.value;
    if (this.props.type === 'phone') {
      dashless = _value.replace(/-/g, '');
      if (dashless.length === 4) {
        value = dashless.slice(0, 3) + '-' + dashless.slice(3);
      } else if (dashless.length === 7) {
        value = dashless.slice(0, 3) + '-' + dashless.slice(3, 6) + '-' + dashless.slice(6);
      } else {
        value = _value;
      }
    } else {
      value = _value;
    }
    return React.createElement("div", {
      "className": form_group_class
    }, (this.props.icon ? React.createElement("i", {
      "className": "fa fa-" + this.props.icon
    }) : void 0), (this.props.type !== 'hidden' ? React.createElement("label", {
      "htmlFor": this.props.name
    }, this.props.label || helpers.humanize(this.props.name)) : void 0), ((function() {
      switch (this.props.type) {
        case 'toggle':
          return React.createElement(Toggle, {
            "options": this.props.options,
            "onChange": this.changeValue,
            "selected": this.props.value
          });
        case 'select':
          return React.createElement("select", {
            "value": this.props.value,
            "onChange": this.changeValue
          }, React.createElement("option", null, this.props.placeholder || 'Select one'), this.props.options.map(function(o) {
            return React.createElement("option", {
              "key": o.value || o,
              "value": o.value || o
            }, o.display || o);
          }));
        case 'textarea':
          return React.createElement("textarea", {
            "key": this.props.name,
            "ref": 'field',
            "name": this.props.name,
            "type": this.props.type,
            "placeholder": this.props.placeholder || helpers.humanize(this.props.name),
            "value": this.props.value,
            "onChange": this.changeValue,
            "autoComplete": this.props.autoComplete,
            "autoCorrect": this.props.autoCorrect
          });
        default:
          return React.createElement("input", {
            "key": this.props.name,
            "ref": 'field',
            "name": this.props.name,
            "type": this.props.type,
            "placeholder": this.props.placeholder || helpers.humanize(this.props.name),
            "value": value,
            "onChange": this.changeValue,
            "autoComplete": this.props.autoComplete,
            "autoCorrect": this.props.autoCorrect
          });
      }
    }).call(this)), (this.props.error ? React.createElement("span", {
      "className": 'error'
    }, this.props.error) : void 0));
  }
});

Toggle = React.createClass({displayName: "Toggle",
  getInitialState: function() {
    return {
      selected: this.props.selected || ''
    };
  },
  select: function(key) {
    return (function(_this) {
      return function() {
        var base;
        _this.value = key;
        _this.setState({
          selected: key
        });
        return typeof (base = _this.props).onChange === "function" ? base.onChange(key) : void 0;
      };
    })(this);
  },
  selected: function(key) {
    if (this.state.selected === key) {
      return 'selected';
    } else {
      return '';
    }
  },
  render: function() {
    return React.createElement("div", {
      "className": 'toggle'
    }, this.props.options.map(this.renderOption));
  },
  renderOption: function(option, i) {
    return React.createElement("a", {
      "key": i,
      "onClick": this.select(option),
      "className": this.selected(option)
    }, option);
  }
});

module.exports = {
  ValidatedField: ValidatedField,
  ValidatedFormMixin: ValidatedFormMixin
};
